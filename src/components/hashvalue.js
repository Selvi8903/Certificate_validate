import { ethers } from 'ethers';
import ContractABI from './CertificateStorageABI.json'; // Import the ABI generated by Remix
import axios from 'axios';



const contractAddress = '0x1a840686800c160689D368408886353755B558e2'; // Address of the deployed contract

// Initialize the Ethereum provider
const provider = new ethers.BrowserProvider(window.ethereum);
const signer = provider.getSigner(); // Get the signer


// Create a contract instance
const contract = new ethers.Contract(contractAddress, ContractABI, signer);

// Function to upload file to Pinata and get the IPFS hash
async function uploadToPinata(file) {
  const formData = new FormData();
  formData.append('file', file);
  
  const res = await axios.post('https://api.pinata.cloud/pinning/pinFileToIPFS', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
      'pinata_api_key': 'e8f83cfae3cd59f5760d',
      'pinata_secret_api_key': '6ec547881b0fc8b748a2ac2cd26a6d172f60da1e43476a1b3bd28882155b1d0c'
    }
  });

  return res.data.IpfsHash;
}

// Function to store hash value in the smart contract
async function storeHashInBlockchain(file) {
  try {
    // Upload file to Pinata
    const ipfsHash = await uploadToPinata(file);

    // Store IPFS hash in the blockchain
    const tx = await contract.storeHash(ipfsHash);
    await tx.wait();
    return { ipfsHash, txHash: tx.hash };
  } catch (error) {
    console.error('Error storing hash in the blockchain:', error);
    throw new Error(`Error storing hash in the blockchain: ${error.message}`);
  }
}

// Function to retrieve and decode IPFS hash value from the blockchain
async function retrieveAndDecodeHash() {
  try {
    // Get the signer's address
    const signerAddress = await signer.getAddress();

    // Retrieve the stored hash from the smart contract
    const storedHash = await contract.getHash(signerAddress);

    // For demonstration, let's just return the stored hash
    return storedHash;
  } catch (error) {
    console.error('Error retrieving and decoding hash:', error);
    return null;
  }
}
const input = contract.methods.verifyHash(hashValue).encodeABI(); // Get encoded input data
    const functionSignature = input.slice(0, 10); // Extract function signature
    const encodedParams = input.slice(10); // Extract encoded parameters
    const decodedParams = web3.eth.abi.decodeParameters(['bytes32'], encodedParams); // Decode parameters

    console.log('Function Signature:', functionSignature);
    console.log('Decoded Parameters:', decodedParams);

export { storeHashInBlockchain, retrieveAndDecodeHash };
